<h1 id="verlet-integration">Verlet Integration</h1>
<p>Verlet Integration is essentially a solution to the kinematic equation for the motion of any object,</p>
<p><br /><span class="math display">$$
x = x_0 + v_0t + \frac{1}{2}at^2 + \frac{1}{6}bt^3 + \cdots
$$</span><br /></p>
<p>Where <br /><span class="math display"><em>x</em></span><br /> is the position, <br /><span class="math display"><em>v</em></span><br /> is the velocity, <br /><span class="math display"><em>a</em></span><br /> is the acceleration, <br /><span class="math display"><em>b</em></span><br /> is the often forgotten jerk term, and <br /><span class="math display"><em>t</em></span><br /> is time. This equation is a central equation to almost every Newtonian physics solver and brings up a class of algorithms known as <em>force integrators</em>. One of the first force integrators to work with is <em>Verlet Integration</em>.</p>
<p>So, let's say we want to solve for the next timestep in <br /><span class="math display"><em>x</em></span><br />. To a close approximation (actually performing a Taylor Series Expansion about <br /><span class="math display"><em>x</em>(<em>t</em>‚ÄÖ¬±‚ÄÖ<em>Œî</em><em>t</em>)</span><br />), that might look like this:</p>
<p><br /><span class="math display">$$
x(t+\Delta t) = x(t) + v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 + \frac{1}{6}b(t) \Delta t^3 + \mathcal{O}(\Delta t^4)
$$</span><br /></p>
<p>This means that if we need to find the next <br /><span class="math display"><em>x</em></span><br />, we need the current <br /><span class="math display"><em>x</em></span><br />, <br /><span class="math display"><em>v</em></span><br />, <br /><span class="math display"><em>a</em></span><br />, etc. However, because few people calculate the jerk term, our error is typically <br /><span class="math display">ùí™(<em>Œî</em><em>t</em><sup>3</sup>)</span><br />. That said, we can calculate <br /><span class="math display"><em>x</em></span><br /> with less knowledge and higher accuracy if we play a trick! Let's say we want to calculate <br /><span class="math display"><em>x</em></span><br /> of the <em>previous</em> timestep. Again, to a close approximation, that might look like this:</p>
<p><br /><span class="math display">$$
x(t-\Delta t) = x(t) - v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 - \frac{1}{6}b(t) \Delta t^3 + \mathcal{O}(\Delta t^4)
$$</span><br /></p>
<p>Now, we have two equations to solve for two different timesteps in x, one of which we already have. If we add the two equations together and solve for <br /><span class="math display"><em>x</em>(<em>t</em>‚ÄÖ+‚ÄÖ<em>Œî</em><em>t</em>)</span><br />, we find</p>
<p><br /><span class="math display"><em>x</em>(<em>t</em>‚ÄÖ+‚ÄÖ<em>Œî</em><em>t</em>)=2<em>x</em>(<em>t</em>)‚àí<em>x</em>(<em>t</em>‚ÄÖ‚àí‚ÄÖ<em>Œî</em><em>t</em>)+<em>a</em>(<em>t</em>)<em>Œî</em><em>t</em><sup>2</sup>‚ÄÖ+‚ÄÖùí™(<em>Œî</em><em>t</em><sup>4</sup>)</span><br /></p>
<p>So, this means, we can find our next <br /><span class="math display"><em>x</em></span><br /> simply by knowing our current <br /><span class="math display"><em>x</em></span><br />, the <br /><span class="math display"><em>x</em></span><br /> before that, and the acceleration! No velocity necessary! In addition, this drops the error to <br /><span class="math display">ùí™(<em>Œî</em><em>t</em><sup>4</sup>)</span><br />, which is great! Here is what it looks like in code:</p>
<p>{% method %} {% sample lang=&quot;jl&quot; %} <a href="code/julia/verlet.jl">import:1-13, lang:&quot;julia&quot;</a> {% sample lang=&quot;cpp&quot; %} <a href="code/c++/verlet.cpp">import:4-19, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;c&quot; %} <a href="code/c/verlet.c">import:3-16, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;java&quot; %} <a href="code/java/verlet.java">import:2-18, lang:&quot;java&quot;</a> {% sample lang=&quot;py2&quot; %} <a href="code/python2/verlet.py">import:28-33, lang:&quot;python&quot;</a> {% sample lang=&quot;hs&quot; %} Unfortunately, this has not yet been implemented in haskell, so here's Julia code: <a href="code/julia/verlet.jl">import:1-13, lang:&quot;julia&quot;</a> {% sample lang=&quot;scratch&quot; %} Unfortunately, this has not yet been implemented in scratch, so here's Julia code: <a href="code/julia/verlet.jl">import:1-13, lang:&quot;julia&quot;</a> {% sample lang=&quot;matlab&quot; %} Unfortunately, this has not yet been implemented in matlab, so here's Julia code: <a href="code/julia/verlet.jl">import:1-13, lang:&quot;julia&quot;</a> {% sample lang=&quot;LabVIEW&quot; %} Unfortunately, this has not yet been implemented in LabVIEW, so here's Julia code: <a href="code/julia/verlet.jl">import:1-13, lang:&quot;julia&quot;</a> {% sample lang=&quot;javascript&quot; %} <a href="code/javascript/verlet.js">import:1-16, lang:&quot;javascript&quot;</a> {% sample lang=&quot;rs&quot; %} <a href="code/rust/verlet.rs">import:1-13, lang:&quot;rust&quot;</a> {% endmethod %}</p>
<p>Now, obviously this poses a problem, what if we want to calculate a term that requires velocity, like the kinetic energy, <br /><span class="math display">$$\frac{1}{2}mv^2$$</span><br />? In this case, we certainly cannot get rid of the velocity! Well, we can find the velocity to <br /><span class="math display">ùí™(<em>Œî</em><em>t</em><sup>2</sup>)</span><br /> accuracy by using the Stormer-Verlet method, which is the same as before, but we calculate velocity like so</p>
<p><br /><span class="math display">$$
v(t) = \frac{x(t+\Delta t) - x(t-\Delta t)}{2\Delta t} + \mathcal{O}(\Delta t^2)
$$</span><br /></p>
<p>Note that the 2 in the denominator appears because we are going over 2 timesteps. It's essentially solving <br /><span class="math display">$$v=\frac{\Delta x}{\Delta t}$$</span><br />. In addition, we can calculate the velocity of the next timestep like so</p>
<p><br /><span class="math display">$$
v(t+\Delta t) = \frac{x(t+\Delta t) - x(t)}{\Delta t} + \mathcal{O}(\Delta t)
$$</span><br /></p>
<p>However, the error for this is <br /><span class="math display">ùí™(<em>Œî</em><em>t</em>)</span><br />, which is quite poor, but get's the job done in a pinch. Here's what it looks like in code:</p>
<p>{% method %} {% sample lang=&quot;jl&quot; %} <a href="code/julia/verlet.jl">import:15-31, lang:&quot;julia&quot;</a> {% sample lang=&quot;cpp&quot; %} <a href="code/c++/verlet.cpp">import:22-40, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;c&quot; %} <a href="code/c/verlet.c">import:18-33, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;java&quot; %} <a href="code/java/verlet.java">import:21-40, lang:&quot;java&quot;</a> {% sample lang=&quot;py2&quot; %} <a href="code/python2/verlet.py">import:35-42, lang:&quot;python&quot;</a> {% sample lang=&quot;hs&quot; %} Unfortunately, this has not yet been implemented in scratch, so here's Julia code: <a href="code/julia/verlet.jl">import:15-31, lang:&quot;julia&quot;</a> {% sample lang=&quot;scratch&quot; %} Unfortunately, this has not yet been implemented in scratch, so here's Julia code: <a href="code/julia/verlet.jl">import:15-31, lang:&quot;julia&quot;</a> {% sample lang=&quot;matlab&quot; %} Unfortunately, this has not yet been implemented in matlab, so here's Julia code: <a href="code/julia/verlet.jl">import:15-31, lang:&quot;julia&quot;</a> {% sample lang=&quot;LabVIEW&quot; %} Unfortunately, this has not yet been implemented in LabVIEW, so here's Julia code: <a href="code/julia/verlet.jl">import:15-31, lang:&quot;julia&quot;</a> {% sample lang=&quot;javascript&quot; %} <a href="code/javascript/verlet.js">import:18-35, lang:&quot;javascript&quot;</a> {% sample lang=&quot;rs&quot; %} <a href="code/rust/verlet.rs">import:15-27, lang:&quot;rust&quot;</a> {% endmethod %}</p>
<p>Now, let's say we actually need the velocity to calculate out next timestep. Well, in this case, we simply cannot use the above approximation and instead need to use the <em>Velocity Verlet</em> algorithm.</p>
<h1 id="velocity-verlet">Velocity Verlet</h1>
<p>In some ways, this algorithm is even simpler than above. We can calculate everything like so</p>
<p><br /><span class="math display">$$
\begin{align}
x(t+\Delta t) &amp;=x(t) + v(t)\Delta t + \frac{1}{2}a(t)\Delta t^2 \\
a(t+\Delta t) &amp;= f(x(t+\Delta t)) \\
v(t+\Delta t) &amp;= v(t) + \frac{1}{2}(a(t) + a(t+\Delta t))\Delta t
\end{align}
$$</span><br /></p>
<p>Which is literally the kinematic equation above, solving for <br /><span class="math display"><em>x</em></span><br />, <br /><span class="math display"><em>v</em></span><br />, and <br /><span class="math display"><em>a</em></span><br /> every timestep. You can also split up the equations like so</p>
<p><br /><span class="math display">$$
\begin{align}
v(t+\frac{1}{2}\Delta t) &amp;= v(t) + \frac{1}{2}a(t)\Delta t \\
x(t+\Delta t) &amp;=x(t) + v(t+\frac{1}{2}\Delta t)\Delta t \\
a(t+\Delta t) &amp;= f(x(t+\Delta t)) \\
v(t+\Delta t) &amp;= v(t+\frac{1}{2}\Delta t) + \frac{1}{2}a(t+\Delta t)\Delta t
\end{align}
$$</span><br /></p>
<p>Here is the velocity Verlet method in code:</p>
<p>{% method %} {% sample lang=&quot;jl&quot; %} <a href="code/julia/verlet.jl">import:33-45, lang:&quot;julia&quot;</a> {% sample lang=&quot;cpp&quot; %} <a href="code/c++/verlet.cpp">import:42-54, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;c&quot; %} <a href="code/c/verlet.c">import:35-46, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;java&quot; %} <a href="code/java/verlet.java">import:43-57, lang:&quot;java&quot;</a> {% sample lang=&quot;py2&quot; %} <a href="code/python2/verlet.py">import:44-48, lang:&quot;python&quot;</a> {% sample lang=&quot;hs&quot; %} Unfortunately, this has not yet been implemented in haskell, so here's Julia code: <a href="code/julia/verlet.jl">import:33-45, lang:&quot;julia&quot;</a> {% sample lang=&quot;scratch&quot; %} Unfortunately, this has not yet been implemented in scratch, so here's Julia code: <a href="code/julia/verlet.jl">import:33-45, lang:&quot;julia&quot;</a> {% sample lang=&quot;matlab&quot; %} Unfortunately, this has not yet been implemented in matlab, so here's Julia code: <a href="code/julia/verlet.jl">import:33-45, lang:&quot;julia&quot;</a> {% sample lang=&quot;LabVIEW&quot; %} Unfortunately, this has not yet been implemented in LabVIEW, so here's Julia code: <a href="code/julia/verlet.jl">import:33-45, lang:&quot;julia&quot;</a> {% sample lang=&quot;javascript&quot; %} <a href="code/javascript/verlet.js">import:37-50, lang:&quot;javascript&quot;</a> {% sample lang=&quot;rs&quot; %} <a href="code/rust/verlet.rs">import:29-40, lang:&quot;rust&quot;</a> {% endmethod %}</p>
<p>Even though this method is more used than the simple Verlet method mentioned above, it unforunately has an error term of <br /><span class="math display">ùí™<em>Œî</em><em>t</em><sup>2</sup></span><br />, which is two orders of magnitude worse. That said, if you want to have a simulaton with many objects that depend on one another --- like a gravity simulation --- the Velocity Verlet algorithm is a handy choice; however, you may have to play further tricks to allow everything to scale appropriately. These types of simulatons are sometimes called <em>n-body</em> simulations and one such trick is the <a href="barnes_hut.md">Barnes-Hut</a> algorithm, which cuts the complexity of n-body simulations from <br /><span class="math display">‚àºùí™(<em>n</em><sup>2</sup>)</span><br /> to <br /><span class="math display">‚àºùí™(<em>n</em>log(<em>n</em>))</span><br /></p>
<h1 id="example-code">Example Code</h1>
<p>Both of these methods work simply by iterating timestep-by-timestep and can be written straightforwardly in any language. For reference, here are snippets of code that use both the classic and velocity Verlet methods to find the time it takes for a ball to hit the ground after being dropped from a given height.</p>
<p>{% method %} {% sample lang=&quot;jl&quot; %} ### Julia <a href="code/julia/verlet.jl">import, lang:&quot;julia&quot;</a> {% sample lang=&quot;cpp&quot; %} ### C++ <a href="code/c++/verlet.cpp">import, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;c&quot; %} ### C <a href="code/c/verlet.c">import, lang:&quot;c_cpp&quot;</a> {% sample lang=&quot;java&quot; %} ### Java <a href="code/java/verlet.java">import, lang:&quot;java&quot;</a> {% sample lang=&quot;py2&quot; %} ### Python <a href="code/python2/verlet.py">import, lang:&quot;python&quot;</a> {% sample lang=&quot;hs&quot; %} ### Haskell <a href="code/haskell/verlet.hs">import, lang:&quot;haskell&quot;</a> {% sample lang=&quot;scratch&quot; %} ### Scratch Submitted by Jie <img src="code/scratch/verlet_scratch.png" alt="Scratch 2D implementation" /> Link: <a href="https://scratch.mit.edu/projects/173039394/" class="uri">https://scratch.mit.edu/projects/173039394/</a> {% sample lang=&quot;matlab&quot; %} ### Matlab <a href="code/matlab/verlet.m">import, lang:&quot;matlab&quot;</a> {% sample lang=&quot;LabVIEW&quot; %} ### LabVIEW Submitted by P. Mekhail <img src="code/labview/verlet_labview.png" alt="Verlet LabVIEW" /> {% sample lang=&quot;javascript&quot; %} ### JavaScript <a href="code/javascript/verlet.js">import, lang:&quot;javascript&quot;</a> {% sample lang=&quot;rs&quot; %} ### Rust <a href="code/rust/verlet.rs">import, lang:&quot;rust&quot;</a> {% endmethod %}</p>
<script>
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>
<p><br /><span class="math display"></span><br /></p>
