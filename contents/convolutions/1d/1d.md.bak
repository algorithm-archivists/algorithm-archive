# Convolutions in 1D
As mentioned in the [introductory section for convolutions](../convolutions.md), convolutions are methods that allow mathematicians to "blend" two seemingly unrelated functions; however, this definition is not very rigorouos, so it might be better to think of a convolution as a method to apply a filter to a signal or image.
This, of course, brings up more questions: what is a filter? What is a signal? How is this all related to images?

For this, we will start with some predefined signal.
It does not matter too much what it is, so we will pick a square wave where everything is set to zero except for a few elements at the center, which will be set to one.
This signal can be treated as an array, or a black and white, one-dimensional image where everything is black except for a white strip at the center.
We will also introduce a filter, which will be a simple triangle wave that goes to 1.
Both of these are shown below:

<p float="center">
    <img src="../res/square_wave.png" style="width:49%">
    <img src="../res/triangle_wave.png" style="width:49%">
</p>

So now we have a signal and a filter.
How do we apply the filter to the signal?
The easiest way to do this would be to iterate through every point in the signal and blend it with neighboring elements, where each neighboring element is weighted based on the filter value.
So in the case where the triangle wave is only 3 elements (`[0.5, 1, 0.5]`), the output at each point would be

$$
C_n = \frac{A_{n-1}}{2} + A_{n} + \frac{A_{n+1}}{2},
$$

where $$C$$ is the output value, $$A$$ is the input array (a signal or image), and $$n$$ is an iterable element through that signal.
In this way, the "application of a filter," is simply a multiplication of the triangle wave centered around each point in the image followed by in integral or sum of the output.
In some sense, this means we will shift the filter, then multiply and sum every step.
This can be seen in the following animation:

<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/triangle_square_conv.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

Here, the purple, dashed line is the output convolution $$C$$, the vertical line is the iteration $$n$$, the blue line is the original signal, the red line is the filter, and the green area is the signal multiplied by the filter at that location.
The convolution at each point is the integral (sum) of the green area for each point.

If we extend this concept into the entirety of discrete space, it might look like this:

$$(f*g)[n] = \sum_{m = -\infty}^{\infty}f[m]g[n-m] = \sum_{m = -\infty}^{\infty}f[n-m]g[m]$$

Where `f[n]` and `g[n]` are arrays of some form.
This means that the convolution can calculated by shifting either the filter along the signal or the signal along the filter.
There is, of course, a small caveat here.
Why are we subtracting $$m$$?
Certainly, if we wanted to "shift the filter along the signal," we could also do so by *adding* $$m$$ instead, but that is actually an entirely separate operation known as a *correlation*, which will be discussed at a later time.

The simplest interpretation for this equation is the same as the animation: we reverse the second array, and move it through the first array one step at a time, performing a simple element-wise multiplication and summation at each step.
With this in mind, we can almost directly transcribe the discrete equation into code like so:

{% method %}
{% sample lang="jl" %}
[import:29-48, lang:"julia"](../code/julia/1d_convolution.jl)
{% endmethod %}

In contrast to the animation, where the filter continuously reappears on the left edge of the screen, the code we have written for this part of the chapter requires the user to specify what they expect the output array length to be.
Determining what should happen at the edges of the convolution is a somewhat hotly debated topic and differs depending on what the user actually wants, so we will be discussing this in greater detail later in this chapter.

As an important note, if we were to extend the convolution into continuous space, we might write something like:

$$(f*g)(x) = \int_{-\infty}^{\infty}f(\xi)g(x-\xi)d\xi = \int_{-\infty}^{\infty}f(x-\xi)g(\xi)d\xi$$

Note that in this case, $$x$$ and $$\xi$$ are not necessarily spatial elements.
The interpretation is the same as before.

At this stage, the mathematics and code might still be a little opaque, so it is a good idea to play around a bit and think about how this operation might be used in practice with a few different filters.

## Playing with filters

Honestly, the best way to learn how convolutions work is by using them for a number of different signals and filters, so
let us extend the previous triangle filter a bit further by convolving a square wave with a relatively sharp Gaussian, which can be seen in the following animation:

<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_gaussian.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

In practice, the convolutional output here is very similar to the triangle wave we showed before.
The final convolved image lookes a lot like the square, except that its boundaries have been smoothed out or "blurred."
In practice whenever a Gaussian filter is used, it will always blur the other convolved signal, which is why a convolution with a Gaussian is also called a *blurring operation*.
This operation is used very often when dealing with two-dimensional images, and we will discuss common kernels found in the wild in the next section on [convolutions of images](../2d/2d.md).
Still, it is interesting to see the blurring operation in action by convolving a random distribution with a larger gaussian filter:

<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_rand_gaussian_cyclic.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

In this animation, the final convolution is so blurred that it seems only slightly related to the random input signal.
In fact, this animation seems to average much more when compared to the previous Gaussian and the triangle wave animations.
This is because the Gaussian is wider than the previous to filters.
In general, the wider the filter, the stronger the blurring effect.

This brings up a rather interesting point.
What happens if we convolve a Gaussian with another Gaussian?
Well, that is shown below:

<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/double_gaussian.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

As one might expect, the output is a blurrier Gaussian, which is essentially just wider.
As an interesting note here, the green area inside this visualization does not properly line up with the overlap of the two arrays.
This is exactly what should happen!
Remember that the convolution requires a *multiplication* of the signal and filter, which is only the overlap of the two arrays when the signal is a square wave.

Let us extend this concept to one final example of a square wave convolved with a triangular, sawtooth function that looks like this:

<p>
  <img  class="center" src="../res/sawtooth.png" style="width:60%" />
</p>

This is the first non-symmetric filter of this chapter, and its convolution would look like this:

<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_sawtooth.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

Non-symmetric filters are useful for testing convolutions to ensure that the output is correct, so it might be worthwhile to linger on this animation for a bit longer.
Notice how the convolution has an accelerating, positive slope when the reversed sawtooth function interacts with the square.
This makes sense as the smallest part of the triangle interacts first.
Similarly, there is a negatively accelerating slope when the sawtooth function leaves the square.

## Dealing with boundaries

In all of the animations, we have shown the filter constantly reappearing on the left edge of the screen.
That said, this is not always the best thing to do at the boundaries.
In fact, these boundary conditions are somewhat non-trivial to code, so we will start with relatively simple boundary conditions that were actually introduced in the previous code example.

### Simple boundaries

In general, if a user wants to see a full convolution between two signals, the output size must be the size of the two signals put together, otherwise, we cannot iterate through the entire convolutional output domain.
For example, here is random noise again convolved with a Gaussian function, but with non-periodic boundaries:

<div style="text-align:center">
<video style="width:90%" controls>
  <source src="../res/1d_rand_gaussian_full.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

This shows the full, unbounded convolution of the two signals, where
we clearly see a "ramp up" and "ramp down" phase at the start and end of the animation.
That said, there are many applications where the user actually needs to specify the output domain to be another length, such as the size of one of the input signals.

In this case, the simplest boundary would be to assume that whenever the filter hits the end of the image, it simply disappears.
Another way to think about this is that the signal only exists for the domain we specify it over, and is all 0s outside of this domain; therefore, the filter does not sum any signal from elements beyond its scope.
As an example, let's take the same example as before:

<div style="text-align:center">
<video style="width:90%" controls>
  <source src="../res/1d_rand_gaussian_simple.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

Similar to the case without boundary conditions, this convolution needs to "ramp up," but not "ramp down."
This is because the convolution output no longer extends past the bounds of the original signal.
More than that, the convolution does not go all the way to 0.
This means that we are actually ignoring a rather important part of the convolution!

This is 100% true; however, if the signal is large and the filter is small (as is the case with most of image processing), we do not really need to care that much about the bits of the convolution we missed.
For this reason, simple bounds are used frequently when performing convolutions on an image.

In the previous code snippet, we were able to perform both a bounded and unbounded convolution.
Here it is again for clarity:

{% method %}
{% sample lang="jl" %}
[import:29-48, lang:"julia"](../code/julia/1d_convolution.jl)
{% endmethod %}

Here, the main difference between the bounded and unbounded versions is that the output array size is smaller in the bounded case.
For an unbounded convolution, the function would be called with a the output array size specified to be the size of both signals put together:

{% method %}
{% sample lang="jl" %}
[import:62-63, lang:"julia"](../code/julia/1d_convolution.jl)
{% endmethod %}

On the other hand, the bounded call would set the output array size to simply be the length of the signal

{% method %}
{% sample lang="jl" %}
[import:65-66, lang:"julia"](../code/julia/1d_convolution.jl)
{% endmethod %}

That is it for simple boundary conditions.
Now let us talk a bit more in detail about the boundaries in the animations!

### Periodic boundary conditions

Another relatively simple boundary condition is the periodic boundary condition.
With this condition, the filter will wrap itself around to the other end of the signal whenever it hits a boundary.
In this way, the signal is periodic, with an identical copy of itself acting as left and right neighbors.
Those neighbors then have other neighbors, and those then have more neighbors, creating a sea of signals extending to infinity and beyond in both directions.
For us, this means that when the filter leaves one edge of the domain, it simply appears on the other, opposite edge.

This particular convolution is known as a *cyclic* convolution and is also the most common output of convolutions that work via the [convolutional theorem](../convolutional_theorem/convolutional_theorem.md), which will be discussed in another section.
For clarity: here is the same cyclic visualization we showed above with a random distribution and a Gaussian signal.

<div style="text-align:center">
<video style="width:90%" controls loop>
  <source src="../res/1d_rand_gaussian_cyclic.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

In code, this typically amounts to using some form of modulus operation, as shown here:

{% method %}
{% sample lang="jl" %}
[import:4-27, lang:"julia"](../code/julia/1d_convolution.jl)
{% endmethod %}

As a final note before continuing: dealing with boundaries is tricky business and can dramatically change the behaviour of the output convolution.
For this reason, it is important to think about what types of boundaries will work best for what you, the programmer, actually needs.
The selection of boundary conditions will be a common trope for a large portion of computer graphics and physics algorithms where researchers often need to present and simulate data on an array of some sort.

## Multiplication as a convolution

As a final note to end this section, we will touch on a rather interesting side topic about how integer multiplication and convolutions are related.
As an example, let us consider the following multiplication: $$123 \times 456 = 56088$$.

In this case, we might line up the numbers, like so:

$$
\begin{matrix}
&&1&2&3 \\
&\times &4&5&6 \\
\hline
5 & 6 & 0 & 8 & 8
\end{matrix}
$$

Here, each column represents another power of 10, such that in the number 123, there is 1 100, 2 10s, and 3 1s.
So let us use a similar notation to perform the convolution, by reversing the second set of numbers and moving it to the right, performing an element-wise multiplication at each step:

$$
\begin{matrix}
&0&0&\color{red}1&2&3 \\
\times &6&5&\color{red}4&0&0 \\
\hline
\end{matrix}\\
\color{red}{1}\times\color{red}{4} = 4
$$

$$
\begin{matrix}
&0&0&\color{red}1&\color{green}2&3 \\
\times &0&6&\color{red}5&\color{green}4&0 \\
\hline
\end{matrix}\\
\color{red}1\times\color{red}5+\color{green}2\times\color{green}4=13
$$

$$
\begin{matrix}
&0&0&\color{red}1&\color{green}2&\color{blue}3 \\
\times &0&0&\color{red}6&\color{green}5&\color{blue}4 \\
\hline
\end{matrix}\\
\color{red}1\times\color{red}6+\color{green}2\times\color{green}5+\color{blue}3\times\color{blue}4=28
$$

$$
\begin{matrix}
&0&1&\color{green}2&\color{blue}3&0 \\
\times &0&0&\color{green}6&\color{blue}5&4 \\
\hline
\end{matrix}\\
\color{green}2\times\color{green}6+\color{blue}3\times\color{blue}5=27
$$

$$
\begin{matrix}
&1&2&\color{blue}3&0&0 \\
\times &0&0&\color{blue}6&5&4 \\
\hline
\end{matrix}\\
\color{blue}3\times\color{blue}6=18
$$

In the end, we will have a new set of numbers:

$$
\begin{matrix}
&&1&2&3 \\
&\times &4&5&6 \\
\hline
4 & 13 & 28 & 27 & 18
\end{matrix}
$$

Now all that is left is to perform the *carrying* operation by moving any number in the 10s digit to its left-bound neighbor.
For example, the numbers $$[4, 18]=[4+1, 8]=[5,8]$$ or 58.
For these numbers, 

$$
\begin{matrix}
&4 & 13 & 28 & 27 & 18\\
=&4+1 & 3+2 & 8+2 & 7+1 & 8\\
=&5 & 5 & 10 & 8 & 8\\
=&5 & 5+1 & 0 & 8 & 8\\
=&5 & 6 & 0 & 8 & 8
\end{matrix}
$$

Which give us $$123\times456=56088$$, the correct answer for integer multiplication.
I am not suggesting that we teach elementary school students to learn convolutions, but I do feel this is an interesting fact that most people do not know: integer multiplication can be performed with a convolution.

This will be discussed in further detail when we talk about the Schonhage-Strassen algorithm, which uses this fact to perform multiplications for incredibly large integers.

## Example Code

For the full code, we have used the convolution to generate a few files for the full convolution and the periodic and simple boundary conditions discussed in this chapter.
At a test case, we have chosen to use a random distribution for the input signal and a gaussian filter.

{% method %}
{% sample lang="jl" %}
[import, lang:"julia"](../code/julia/1d_convolution.jl)
{% endmethod %}

<script>
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>

## License

##### Code Examples

The code examples are licensed under the MIT license (found in [LICENSE.md](https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md)).

##### Images/Graphics
- The image "[Square Wave](../res/square_wave.png)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The image "[Triangle Wave](../res/triangle_wave.png)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The video "[Triangle Square Convolution](../res/triangle_square_conv.mp4)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The video "[Gaussian Square Convolution](../res/1d_gaussian.mp4)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The video "[Gaussian Random Convolution](../res/1d_rand_gaussian_cyclic.mp4)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The video "[Double Convolution](../res/double_gaussian.mp4)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The image "[Sawtooth Wave](../res/sawtooth.png)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The video "[Sawtooth Square Convolution](../res/1d_sawtooth.mp4)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The video "[Full Random Convolution](../res/1d_rand_gaussian_full.mp4)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
- The video "[Simple Random Convolution](../res/1d_rand_gaussian_simple.mp4)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).


##### Text

The text of this chapter was written by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).

[<p><img  class="center" src="../../cc/CC-BY-SA_icon.svg" /></p>](https://creativecommons.org/licenses/by-sa/4.0/)

##### Pull Requests

After initial licensing ([#560](https://github.com/algorithm-archivists/algorithm-archive/pull/560)), the following pull requests have modified the text or graphics of this chapter:
- none

