# Affine Transformations

Affine transformations are a class of vector operations that encompass rotation, scaling, translation, shearing, and several similar transformations regularly used in a number of areas in mathematics and computer graphics.
To start, I would like to discuss the basics of transformation matrices and linear transformations before moving on to the guarantees of affine transforms and then discussing a common strategy for implementing affine transformations in code: the augmented transformation matrix.

## A quick intro to affine (and linear) transforms

Transformation matrices are simply ways to transform a provided vector into another one.
At first glance, this is not a particularly interesting concept; however, many different algorithms rely on understanding how they work.

So let us start with a provided point $$(x,y)$$ on a two-dimensional plane.
If we treat this point as a $$1 \times 2$$ vector, then we can transform it into another $$1 \times 2$$ vector by multiplying it with a $$2 \times 2$$ transformation matrix.
Similarly, a three-dimensional point would need a $$3 \times 3 $$ sized transformation matrix.
These types of transformations are known as linear transformation and are often notated as,

$$
\mathbf{v} = \mathbf{A}\mathbf{v}_0.
$$

Here, $$\mathbf{A}$$ is an $$n\times n$$ transformation matrix, where $$n$$ is the length of the input and output location vector, $$\mathbf{v_0}$$ and $$\mathbf{v}$$, respectively.
Affine transformations are allow us to also translate our initial points such that

$$
\textbf{v} = \mathbf{A}\mathbf{v}_0 + \ell.
$$

Here, $$\ell$$ is an $$n\times 1$$ translation vector.
To understand the power of these transformations, it is important to see them in practice:

| Description | Transform |
| ----------- | --------- |
| Scaling along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a11_square_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Scaling along $$y$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a22_square_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Shearing along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a12_square_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Shearing along $$y$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a21_square_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Translation along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a13_square_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Translation along $$y$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a23_square_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |

For all of these visualizations, we show a set of 4 points multiplied by small variations to the identity matrix.
These variations are shown as numeric changes to the matrix and also as small dials underneath which correspond to the "amount by which we have modified the value from its original location.

### Rotation: a special side-note

One special linear transformation that everyone loves is rotation; however, when I initially learned about how to perform rotation in this way, I did not really understand how it worked.
For this reason, I think it is important to delve a bit deeper into this topic, hopefully providing an intuitive explanation for those who are new (and potentially those who already use the rotation matrix regularly, but do not fully understand it).

The simplest way to think about this transformation is to first recognize that shearing in one direction along $$x$$ and then another direction along $$y$$ will create a "pseudo-rotation" effect.
Unfortunately, because of the shaering, the points will also move further away from the origin.
For this reason, an additional scaling along $$x$$ and $$y$$ is important.
This can be explained in more detail with the following animation:

<div style="text-align:center">
<video style="width:100%" controls loop>
  <source src="res/semi_rotate_white.mkv" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

Now the only question is, *How do we know the amount we need to shear and scale?*

Well, the answer here is not particularly surprising.
If we want to rotate our points, we probably want to imagine rotation along a circle by some angle $$\theta$$.
We also know that the identity matrix should correspond to an unrotated object with $$\theta = 0$$.
For this reason, we know that two elements should start at 1 and the other two should start at 0.
We also know that the shearing should happen in opposite directions, so we might guess that the rotation matrix would be:

$$
\mathbf{A}_{\text{rot}} = \begin{bmatrix}
\cos(\theta) & -\sin(\theta) \\
\sin(\theta) & \cos(\theta) \\
\end{bmatrix}
$$

In this case, the amount we want to shear should start at 0 when $$\theta = 0$$ and then go to $$\pm 1$$ when $$\theta = \pm \pi/2$$, which is the behaviour of $$\sin(\theta)$$.
Meanwhile, the scale factor at 1 when $$\theta = 0$$ and go to $$0$$ when $$\theta = \pi/2$$, which is the behavior of $$\cos(\theta)$$.

It is worth dwelling a bit on this point.
If the scale factor is 0, surely this means that all points on the square are also at 0, right?
Well, not exactly.
In this case,

$$
\mathbf{A} = \begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}
\rightarrow
\begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix}
$$

As an example, let us multiply the vector $$[1,2]$$ with both of these matrices:

$$
\begin{align}
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
1 \\
2 \\
\end{bmatrix}
&=
\begin{bmatrix}
1 \\
2 \\
\end{bmatrix},\\


\begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
1 \\
2 \\
\end{bmatrix}
&=
\begin{bmatrix}
2 \\ 
1 \\
\end{bmatrix}.

\end{align}
$$

Here, we see that when multiplying by the identity matrix, the vector remains the same, but when multiplying by the second matrix, the x and y components flip.
Essentially, all of the vector moved into the "shear" component, while none of it remains in the "scale" component.

Before continuing to show the $$\mathbf{A}_{\text{rot}}$$ above, it is worth considering two somewhat related matrices, where the identity matrix is modified with only the $$\sin(\theta)$$ or $$\cos(\theta)$$ components.

| Description | Transform |
| ----------- | --------- |
| Just sines | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/sines_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Just cosines | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/cosines_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |

Here, we see two interesting cases:

1. In the case of the sine modifications, we see that as $$\theta$$ wraps around from $$0 \rightarrow 2\pi$$, the seems to grow and rotate like expected, but at $$\pi/2$$, it seems to abruptly move in the other direction.
2. In the case of the cosine modifications, we see the square flip around entirely at $$\pi/2$$.

When put together, they form a full rotation:

<div style="text-align:center">
<video style="width:100%" controls loop>
  <source src="res/semi_rotate_white.mkv" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

At least for me, it took some thinking to figure out why the two animations above will form a full rotation when put together.
When thinking about it, it makes sense that at $$\pi/2$$, the sine component will start to slowly rotate back, but will be tugged along in the opposite direction by the cosine component that has turned negative at the same time.

Overall, the rotation matrix is a fun and interesting application to linear transformations that really helped me understand how the entire class of operations functions.

### Guarantees of affine transformations

As a class of vector operations, affine transformations preserve the following:

1. **collinearity between points**. This means that any points that lie on the same line before an affine transform must be on that same line after the transform. The line can still change in slope or position.
2. **parallelism between lines**. Any lines parallel before the transform must also be parallel after.
3. **ratios of the lengths of parallel line segments**. This means if you have two different line segments, one of which is parameterized by $$p_1$$ and $$p_2$$, while the other is parameterized by $$p_3$$ and $$p_4$$, then $$\frac{\vec{p_1 p_2}}{\vec{p_3 p_4}}$$ must be the same before and after transformation.
4. **convexity of any transformed shape**. If a shape does not have any concave component (a point that points in towards it's center), then it cannot have a concave component after the transformation.
5. **barycenters of the collection of points**. The barycenter is the collective center of mass of the system, like the balancing point for a plate. There is an equal amount of "stuff" on either side of the barycenter. This location must remain at the same location relative to each point after transformation.

ADD MORE

## Augmented matrix implementation

Because affine transformations are basically a mix of a transformation matrix and translation, many implementations will combine both of these into a large $$3 \times 3$$ transformation matrix for a two-dimensional vector.
If you are like me, this might be a bit confusing.
If the two-dimensional vector is described by a $$1 \times 2$$ array, then how do you do a matrix multiplication with a $$3 \times 3$$ array?

To be honest, the answer *feels* like a bit of a hack: we simply append a 1 to the end of the input, output, and translation vectors, such that:

$$
\begin{bmatrix}
\mathbf{v} \\
1 \\
\end{bmatrix}
=
\left[\begin{array}{@{}ccc|c@{}}
 & \mathbf{A} &  & \ell \\
0 & \cdots & 0 & 1 \\
\end{array}\right]
\begin{bmatrix}
\mathbf{v}_0 \\
1
\end{bmatrix}
$$

So, using 

$$
\begin{align}
\mathbf{v}_0 &= \begin{bmatrix}
1 \\ 
2 \\
\end{bmatrix} \\
\mathbf{A} &= \begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix} \\
\ell &= \begin{bmatrix}
0 \\ 
0 \\
\end{bmatrix}
\end{align},
$$

we would do the following computation:

$$
\begin{bmatrix}
\mathbf{v} \\
1 \\
\end{bmatrix}
=
\left[\begin{array}{@{}cc|c@{}}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1 \\
\end{array}\right]
\begin{bmatrix}
2 \\
1 \\
1
\end{bmatrix}
$$

Doing this, we would again find that $$\mathbf{v} = [2,1]$$.
Ok, now we need to talk about why this works.

Adding the 1 to the end of the vectors essentially turn them into three dimensions, with the $$z$$ dimension simply set to be 1.
The easiest way to visualize this is by thinking of the top plane on a greater cube, so here are the same vector operations as before on that cube:


| Description | Transform |
| ----------- | --------- |
| Scaling along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a11_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Scaling along $$y$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a22_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Shearing along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a12_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Shearing along $$y$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a21_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Translation along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a13_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Translation along $$y$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a23_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |

The shear and scaling operations seem about the same as before; however, the translation operations are now clearly a shear along the entire cube!
The only reason this acts as translation for two dimensions is because we only care about the top slab of the cube.

Now, the reason I always feel this implementation is a bit of a hack is because there's a little black magic that everyone keeps quiet about: the last row in the matrix.
Namely, people just set it to $$[0, 0, 1]$$ and leave it be, never touching it again...
But that is terribly unsatisfying!

What would happen if we actually touched those knobs and modified the bottom row?
Well...


| Description | Transform |
| ----------- | --------- |
| Scaling along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a31_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Scaling along $$y$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a32_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |
| Shearing along $$x$$ | <div style="text-align:center"> <video style="width:100%" controls loop> <source src="res/a33_cube_white.mkv" type="video/mp4"> Your browser does not support the video tag. </video> </div> |

In this case, the first two components are shearing along $$z$$ and $$x$$ and $$z$$ and $$y$$, while the last component is a scale along $$z$$.
If one was taking a picture from above, none of these transformations would be visible; however, it is nice to show that linear transformations still work in higher dimensions.

Finally, let us go back to the rotation example:

<div style="text-align:center">
<video style="width:100%" controls loop>
  <source src="res/rotation_cube_white.mkv" type="video/mp4">
Your browser does not support the video tag.
</video>
</div>

Here, we see that we can embed just about any affine transformation into 3D space and still see the same results, and I think that is a nice place to end on: affine transformations are linear transformations in an $$n+1$$ dimensional space.

### Bibliography

{% references %} {% endreferences %}

<script>
MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
</script>

## License

##### Code Examples

The code examples are licensed under the MIT license (found in [LICENSE.md](https://github.com/algorithm-archivists/algorithm-archive/blob/master/LICENSE.md)).

##### Text

The text of this chapter was written by [James Schloss](https://github.com/leio) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).

[<p><img  class="center" src="../cc/CC-BY-SA_icon.svg" /></p>](https://creativecommons.org/licenses/by-sa/4.0/)

##### Images/Graphics
- The video "[A11 square](res/a11_square_white.mkv)" was created by [James Schloss](https://github.com/leios) and is licensed under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/legalcode).
